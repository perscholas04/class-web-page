const e=e=>"string"==typeof e&&e.length>0,t=e=>"function"==typeof e,n=e=>"string"==typeof e&&0===e.length,r=e=>null==e||n(e),s=(e,t)=>{const n=t-e+1;return Array.from({length:n},((t,n)=>n+e))},i=(e,t)=>{if(!e)return null;const n=Object.entries(e).filter((e=>e[0].startsWith(t)));return Object.assign({},...Array.from(n,(([e,n])=>({[e.replace(t,"")]:n}))))},c=(e,t)=>{if(!e)return null;const n=Object.entries(e).filter((([e])=>e===t)).flatMap((([,e])=>Object.entries(e))).filter((e=>null==e?void 0:e[0]));return Object.fromEntries(n)};function l(e,t){const n=[...new Set(e.flatMap((e=>Object.keys(e.variantValues))))],r=Object.keys(t).filter((e=>n.includes(e)&&t[e])).reduce(((e,n)=>(e[n]=t[n],e)),{});return e.filter((({variantValues:e})=>Object.keys(e).length===Object.keys(r).length&&Object.entries(e).every((([e,t])=>r[e]===t)))).reduce(((e,t)=>Object.assign(Object.assign({},e),t.overrides)),{})}const a=(e,t)=>{if(!e&&!t)return null;if(!t)return e;if(!e)return t;const n=new Set(Object.keys(t)),r=Object.keys(e).filter((e=>n.has(e))),s=Object.fromEntries(r.map((n=>[n,Object.assign(Object.assign({},e[n]),t[n])])));return Object.assign(Object.assign(Object.assign({},e),t),s)};export{i as findChildOverrides,s as getConsecutiveIntArray,c as getOverrideProps,l as getOverridesFromVariants,n as isEmptyString,t as isFunction,r as isNullOrEmptyString,a as mergeVariantsAndOverrides,e as strHasLength};
